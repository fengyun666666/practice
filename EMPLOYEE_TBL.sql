/*创建表*/

CREATE TABLE EMPLOYEE_TBL(
	EMP_ID CHAR(9) NOT NULL,
	EMP_NAME VARCHAR(40) NOT NULL,
	EMP_ST_ADDR VARCHAR(20) NOT NULL,
	EMP_CITY VARCHAR(15) NOT NULL,
	EMP_ST  CHAR(2) NOT NULL,
	EMP_ZIP INTEGER(5) NOT NULL,
	EMP_PHONE INTEGER(10) NULL,
	EMP_PAGER INTEGER(10) NULL
);



/*创建有自动增长的序列号的列*/
CREATE TABLE TEST_INCREMENT(
	TEST_ID SERIAL,
	TEST_CONTENT VARCHAR(20)
);

INSERT INTO TEST_INCREMENT VALUES("TEST1","TEST2");

INSERT INTO TEST_INCREMENT(TEST_CONTENT) VALUES("TEST1"),("TEST3");

/*循环插入数据*/
delimiter  //
CREATE PROCEDURE EMPLOYEE_PAY_TBL()
	begin
	DECLARE  i int;
	set i = 0;
	while i<10 do 
	INSERT INTO EMPLOYEE_PAY_TBL VALUES(i,'poition',"date1","date2");
	set i = i+1;
	end while;
	end;
	//

/*调用存储过程*/
call EMPLOYEE_PAY_TBL;

/*从一张表创建一张新表,数据也会同步过去*/
CREATE TABLE TEST_NEW AS SELECT * FROM TEST_INCREMENT;

/*删除一张表，如果有视图或事务引用它，删除不成功*/
drop table TEST_NEW restrict;

/*创建含有外键约束的表*/
CREATE TABLE EMPLOYEE_PAY_TBL(
	EMP_ID CHAR(10) NOT NULL,
	POSITION VARCHAR(15) NOT NULL,
	DATE_HIRE DATE NULL,
	DATE_LAST_RAISE  DATE NULL
); 

/*使用alter添加约束*/
ALTER TABLE EMPLOYEE_PAY_TBL ADD CONSTRAINT PRIMARY KEY(EMP_ID);
ALTER TABLE EMPLOYEE_PAY_TBL ADD CONSTRAINT EMP_ID_FK FOREIGN KEY(EMP_ID) REFERENCES EMPLOYEE_TBL(EMP_ID);

/*删除约束*/
ALTER TABLE EMPLOYEE_PAY_TBL DROP PRIMARY KEY;

/*插入数据*/
INSERT INTO EMPLOYEE_PAY_TBL VALUES('2','SHAGNHAI','2018-9-10','2018-9-10');

/*修改数据--一定要注意where条件，基本都要写进入*/
UPDATE EMPLOYEE_PAY_TBL SET POSITION = 'SHANGHAI' WHERE EMP_ID = 2;

UPDATE EMPLOYEE_PAY_TBL SET POSITION = 'BEIJIGN' , DATE_HIRE = '2018-10-10' WHERE EMP_ID = 2;

/*删除数据*/
DELETE FROM EMPLOYEE_PAY_TBL WHERE EMP_ID = 2; 

/*撤销事务*/
CREATE TABLE PRODUCT_TMP(
	PROD_ID VARCHAR(10) NOT NULL,
	PROD_DESC VARCHAR(20) NOT NULL,
	COST DOUBLE  NOT NULL
);
INSERT INTO PRODUCT_TMP VALUES('1','TEST1',29.99);

BEGIN;#开启事务
SELECT * FROM PRODUCT_TMP;
UPDATE PRODUCT_TMP SET COST = 59.99 WHERE PROD_ID = 1;
ROLLBACK;

/*保存事务点*/--没有验证成功
SAVEPOINT SAVEPOINT1;

/*回退事务*/
ROLLBACK to SAVEPOINT1;   //命令报错

/*删除回退点*/
RELEASE SAVEPOINT SAVEPOINT1;    //命令报错


/*初始化数据库事务*/  --报错
SET TRANSACTION READ WRITE;
SET TRANSACTION READ ONLY;

/*更改数据的引擎*/
ALTER TABLE PRODUCT_TMP engine = innodb;


DELETE FROM  PRODUCT_TMP where PROD_ID = 1;
SAVEPOINT DEL1;
DELETE FROM PRODUCT_TMP WHERE PROD_ID = 2;
SAVEPOINT DEL4;
DELETE FROM PRODUCT_TMP WHERE PROD_ID = 3;
SAVEPOINT DEL3;



delimiter //
	CREATE PROCEDURE PROCEDURE_TMP_P()
	begin
	declare i int;
	set i = 0;
	while i < 10 do
	INSERT INTO PRODUCT_TMP VALUES(i,'test',i+9.99);
	set i = i+1;
	end while;
	end;
	//

delimiter ;
call PROCEDURE_TMP_P;

#添加用户：

insert into mysql.user(Host,User,Password) values("%",'cwb','cwb');
GRANT ALL PRIVILEGES ON *.*  TO 'cwb'@'%' identified by 'cwb';
GRANT select,delete,update,create,drop on *.* to 'cwb'@'%' identified by 'cwb';
flush PRIVILEGES;

#删除用户
DELETE FROM user WHERE User='cwb' and Host = 'localhost';


/*第七章*/
#select+distinct语句
SELECT DISTINCT (PROD_DESC) FROM PRODUCT_TMP;

#select+ORDER BY语句
SELECT * FROM PRODUCT_TMP WHERE PROD_DESC = 'test' and COST <10 OR COST >18 ORDER BY COST DESC;
SELECT * FROM PRODUCT_TMP WHERE PROD_DESC = 'test' and COST <10 OR COST >18 ORDER BY 3 DESC;

#统计表的记录数量
SELECT COUNT(*) FROM PRODUCT_TMP;
SELECT DISTINCT COUNT( *) FROM PRODUCT_TMP;

#select别名
SELECT PROD_DESC , PROD_DESC as TEST FROM PRODUCT_TMP;

/*第八章*/
#SELECT详解-比较操作符
SELECT * FROM PRODUCT_TMP WHERE COST = 9.99;
SELECT * FROM PRODUCT_TMP WHERE COST > 9.99;
SELECT * FROM PRODUCT_TMP WHERE COST < 10;
SELECT * FROM PRODUCT_TMP WHERE COST <> 9.99;
SELECT * FROM PRODUCT_TMP WHERE COST != 9.99;
SELECT * FROM PRODUCT_TMP WHERE COST <= 9.99;

#逻辑操作符
SELECT * FROM PRODUCT_TMP WHERE COST IS NULL;
SELECT * FROM PRODUCT_TMP WHERE COST BETWEEN 10 AND 15;
SELECT * FROM PRODUCT_TMP WHERE COST IN ('11.99','12.99');
SELECT * FROM PRODUCT_TMP WHERE PROD_DESC LIKE '%E_T';

#注意一下不能有多余的回车
SELECT * FROM PRODUCT_TMP WHERE  EXISTS (SELECT PROD_DESC FROM PRODUCT_TMP WHERE PROD_ID = 2);

SELECT COST FROM PRODUCT_TMP WHERE COST > ALL (SELECT COST FROM PRODUCT_TMP WHERE COST < 15);
SELECT COST FROM PRODUCT_TMP WHERE COST > SOME (SELECT COST FROM PRODUCT_TMP WHERE COST < 15);
SELECT COST FROM PRODUCT_TMP WHERE COST > ANY (SELECT COST FROM PRODUCT_TMP WHERE COST < 15);

#连接操作符
SELECT COST FROM PRODUCT_TMP WHERE COST > 10 AND COST < 15;
SELECT COST FROM PRODUCT_TMP WHERE COST > 10 OR COST < 10;

#求反操作符--NOT
SELECT * FROM PRODUCT_TMP WHERE COST IS NOT NULL;

#算数操作符
SELECT * FROM PRODUCT_TMP WHERE COST + COST1 > '20';
SELECT COST + COST1 AS HE FROM PRODUCT_TMP WHERE COST > 15;

SELECT * FROM PRODUCT_TMP WHERE COST - COST1 > '20';
SELECT COST - COST1 AS HE FROM PRODUCT_TMP WHERE COST > 15;

SELECT * FROM PRODUCT_TMP WHERE COST * COST1 > '20';
SELECT COST * COST1 AS HE FROM PRODUCT_TMP WHERE COST > 15;

SELECT * FROM PRODUCT_TMP WHERE COST / COST1 > '20';
SELECT COST / COST1 AS HE FROM PRODUCT_TMP WHERE COST > 15;

/*第九章*/
#COUNT
select distinct count(*) from PRODUCT_TMP WHERE PROD_ID = 2;

#SUM
select SUM(COST) from PRODUCT_TMP WHERE PROD_ID = 2;
select SUM(PROD_DESC) from PRODUCT_TMP ;  #值为0


#MAX
select MAX(COST) from PRODUCT_TMP WHERE PROD_ID = 2;
select MAX(PROD_DESC) from PRODUCT_TMP ;


#MIN
select MIN(COST) from PRODUCT_TMP WHERE PROD_ID = 2;
select MIN(PROD_DESC) from PRODUCT_TMP ;


#AVG
select AVG(COST) from PRODUCT_TMP WHERE PROD_ID = 2;
select AVG(PROD_DESC) from PRODUCT_TMP ; #值为0


/*第十章*/
#select+order by  --字符型数据按照ASCII进行排序
SELECT EMP_ID1 , ADDRESS FROM EMPLOYEE_TBL ORDER BY EMP_ID1  DESC, ADDRESS;
SELECT EMP_ID1 , ADDRESS FROM EMPLOYEE_TBL ORDER BY EMP_ID1  DESC, ADDRESS DESC;
SELECT EMP_ID1 , ADDRESS FROM EMPLOYEE_TBL ORDER BY 2  DESC, 1 DESC;
SELECT AVG(EMP_ID1) , ADDRESS FROM EMPLOYEE_TBL ORDER BY 2  DESC, 1 DESC;  #此时avg算出的数值是每个EMP_ID1组的平均数值

#select + group by 
SELECT EMP_ID1 , ADDRESS ,COUNT(EMP_ID1) AS NUMBER FROM EMPLOYEE_TBL GROUP BY ADDRESS , EMP_ID1;

#select + group by + ROLLUP
SELECT EMP_ID1 , ADDRESS ,COUNT(EMP_ID1) AS NUMBER FROM EMPLOYEE_TBL GROUP BY ROLLUP(ADDRESS , EMP_ID1);

/*第十一章*/

#tanslate函数 --MYSQL里面没有translate函数
SELECT PROD_DESC, TRANSLATE(PROD_DESC , 'TEST' , 'ABCD') FROM PRODUCT_TMP;   #MariaDB不支持这种语法
SELECT PROD_DESC, replace(PROD_DESC , 'TEST' , 'ABCD') FROM PRODUCT_TMP;

#转成小写函数
SELECT LOWER(PROD_DESC) FROM PRODUCT_TMP;

#转成大写函数
SELECT UPPER(PROD_DESC) FROM PRODUCT_TMP;

#SUBSTR函数--截取函数
SELECT PROD_DESC , SUBSTR(PROD_DESC,1,3) FROM PRODUCT_TMP;

#INSTR函数
SELECT PROD_DESC , INSTR (PROD_DESC,'E') FROM PRODUCT_TMP;


#LTRIM函数--从左侧截取字符串--在mysql中定义不一样，删除了其前置空格字符串
SELECT PROD_DESC , LTRIM (PROD_DESC) FROM PRODUCT_TMP;


#RTRIM函数--从右侧截取字符串--在mysql中定义不一样，删除了其后置空格字符串
SELECT PROD_DESC , RTRIM (PROD_DESC) FROM PRODUCT_TMP;

#DECODE函数--mysql中的定义不同，未实现
SELECT PROD_DESC , DECODE(PROD_DESC,'TEST1','RESULT') FROM PRODUCT_TMP;

#length函数
SELECT PROD_DESC , LENGTH(PROD_DESC) FROM PRODUCT_TMP;
 
#IFNULL函数
SELECT PR_NULL , IFNULL(PR_NULL,99) FROM PRODUCT_TMP;

#COALESCE函数   ---未解决
SELECT 	coalesce(PR_NULL) FROM PRODUCT_TMP;

#LPAD函数
SELECT LPAD(PROD_DESC,30,'.') FROM PRODUCT_TMP;

#RPAD函数
SELECT RPAD(PROD_DESC,30,'.') FROM PRODUCT_TMP;

#ASCII函数
SELECT PROD_DESC,ASCII(PROD_DESC) FROM PRODUCT_TMP;

#绝对值函数
SELECT ABS(-0.85) ;

#舍入函数round
SELECT 	ROUND(0.85);

#平方根sqrt
SELECT 	SQRT(4);

#符号sign
SELECT 	SIGN(-5);

#幂函数power
SELECT 	POWER(2,3);


#上限和下限CEIL、FLOOR
SELECT 	CEIL(3.8);
SELECT 	FLOOR(3.8);

#指数EXP
SELECT 	EXP(3);

#SIN、COS、TAN
SELECT 	SIN(4);
SELECT 	COS(4);
SELECT 	TAN(4);

#数字转换为字符串
SELECT CONCAT(COST) FROM PRODUCT_TMP;

#组合函数
SELECT CONCAT(FIRST_NAME,',',LAST_NAME) AS NAME , CONCAT(SUBSTR(SSN,1,3),'-',SUBSTR(SSN,4,3),'-',SUBSTR(SSN,7,3)) AS ID FROM EMPLOYEE_TBL WHERE EMP_ID1 = 1;

/*第十二章*/
#返回系统日期
SELECT NOW();

#DATE_ADD函数
SELECT DATE_TEST , DATE_ADD(DATE_TEST,INTERVAL 1 DAY)  FROM PRODUCT_TMP;
SELECT DATE_TEST , DATE_ADD(DATE_TEST,INTERVAL 1 MONTH)  FROM PRODUCT_TMP;
SELECT DATE_TEST , DATE_ADD(DATE_TEST,INTERVAL 1 YEAR) , DATE_TEST+100 FROM PRODUCT_TMP;

#日期函数
#返回星期几
SELECT DATE_TEST,DAYNAME(DATE_TEST) FROM PRODUCT_TMP ;

#返回几号
SELECT DAYOFMONTH(DATE_TEST) FROM PRODUCT_TMP ;

#返回day的星期索引，其中星期日为0
SELECT DAYOFWEEK(DATE_TEST) FROM PRODUCT_TMP ;
SELECT DAYOFWEEK('2018-10-9') FROM PRODUCT_TMP ;

#返回一年中的第几天
SELECT DAYOFYEAR(DATE_TEST) FROM PRODUCT_TMP ;

#字符串转换为日期 --转换效果不如意
SELECT STR_TO_DATE('01/01/2010 12:00:00 AM','%m/%d/%Y %h:%i:%s %p') AS TEST ;
SELECT STR_TO_DATE('01/01/2010 11:01:01','%m/%d/%Y %h:%i:%s') AS TEST ;
SELECT STR_TO_DATE('01/01/2010 12:00:00 AM','%m/%d/%Y %h:%i:%s %p') AS TEST FROM PRODUCT_TMP;


/*第十三章*/

#更改表字段
ALTER TABLE PRODUCT_TMP MODIFY COLUMN DATE_TEST DATETIME;
ALTER TABLE PRODUCT_TMP CHANGE DATE_TEST DATE_TEST1 DATE;
	
#内部链接
SELECT EMPLOYEE_TBL.EMP_ID1 ,
	EMPLOYEE_PAY_TBL.EMP_ID
FROM EMPLOYEE_TBL,
	EMPLOYEE_PAY_TBL
WHERE EMPLOYEE_TBL.EMP_ID1 = EMPLOYEE_PAY_TBL.EMP_ID;


SELECT EMPLOYEE_TBL.EMP_ID1 ,
	EMPLOYEE_PAY_TBL.EMP_ID
FROM EMPLOYEE_TBL INNER JOIN EMPLOYEE_PAY_TBL ON EMPLOYEE_TBL.EMP_ID1 = EMPLOYEE_PAY_TBL.EMP_ID;

#使用表的别名
SELECT E.EMP_ID1 ,P.EMP_ID
FROM EMPLOYEE_TBL E INNER JOIN EMPLOYEE_PAY_TBL P ON E.EMP_ID1 = P.EMP_ID;

#不等值结合--会有很多无用的数据
SELECT E.EMP_ID1 ,P.EMP_ID
FROM EMPLOYEE_TBL E ,
	EMPLOYEE_PAY_TBL P 
WHERE E.EMP_ID1 <> P.EMP_ID;

#左外部结合
SELECT E.EMP_ID1 ,P.EMP_ID
FROM EMPLOYEE_TBL E LEFT  JOIN
	EMPLOYEE_PAY_TBL P 
ON E.EMP_ID1 = P.EMP_ID;

#右外部结合
SELECT E.EMP_ID1 ,P.EMP_ID
FROM EMPLOYEE_TBL E RIGHT  JOIN
	EMPLOYEE_PAY_TBL P 
ON E.EMP_ID1 = P.EMP_ID;

#全外部结合 -- mysql不支持全外连接
SELECT E.EMP_ID1 ,P.EMP_ID
FROM EMPLOYEE_TBL E LEFT OUTER JOIN
	EMPLOYEE_PAY_TBL P 
ON E.EMP_ID1 = P.EMP_ID;

#自结合
SELECT A.FIRST_NAME , B.LAST_NAME , B.FIRST_NAME
FROM EMPLOYEE_TBL A,
	EMPLOYEE_TBL B
WHERE A.LAST_NAME = B.LAST_NAME;

#结合多个主键

CREATE TABLE PROD(
	SERIAL_NUMBER  DECIMAL(10) NOT NULL,
	VENDOR_NUMBER  DECIMAL(10) NOT NULL,
	PRODUC_NAME  VARCHAR(30) NOT NULL,
	COST  DECIMAL(8,2) NOT NULL
);

CREATE TABLE ORD(
	ORD_NO DECIMAL(10) NOT NULL,
	PROD_NUMBER DECIMAL(10) NOT NULL,
	VENDOR_NUMBER DECIMAL(10) NOT NULL,
	QUANTITY DECIMAL(5) NOT NULL,
	ORD_DATE DATE NOT NULL
);

SELECT P.PRODUC_NAME , O.QUANTITY 
FROM PROD P INNER JOIN ORD O ON P.SERIAL_NUMBER = O.SERIAL_NUMBER AND P.VENDOR_NUMBER = O.VENDOR_NUMBER;

#使用基表
CREATE TABLE CUSTOMER_TBL(
	CUST_ID VARCHAR(10) NOT NULL PRIMARY KEY,
	CUST_NAME VARCHAR(30) NOT NULL,
	CUST_ADDRESS VARCHAR(20) NOT NULL,
	CUST_CITY VARCHAR(15) NOT NULL,
	CUST_STATE VARCHAR(2) NOT NULL,
	CUST_ZIP INTEGER(5) NOT NULL,
	CUST_PHONE INTEGER(10),
	CUST_FAX INTEGER(10)
);

CREATE TABLE ORDERS_TBL(
	ORD_NUM VARCHAR(10) NOT NULL PRIMARY KEY,
	CUST_ID VARCHAR(10) NOT NULL,
	PROD_ID VARCHAR(10) NOT NULL,
	QTY INTEGER(6) NOT NULL,
	ORD_DATE DATETIME
);

CREATE TABLE PRODUCTS_TBL(
	PROD_ID VARCHAR(10) NOT NULL PRIMARY KEY,
	PROD_DESC VARCHAR(40) NOT NULL,
	COST DECIMAL(6,2) NOT NULL
);

SELECT C.CUST_NAME , P.PROD_DESC
FROM CUSTOMER_TBL C,
	ORDERS_TBL O,
	PRODUCTS_TBL P
WHERE C.CUST_ID = O.CUST_ID
AND P.PROD_ID = O.PROD_ID;

#笛卡尔积--交叉结合--很危险，注意where条件
SELECT C.CUST_NAME , P.PROD_DESC
FROM CUSTOMER_TBL C,
	PRODUCTS_TBL P;


create table EMP(
 	ID INT,
 	NAME VARCHAR(20),
 	MGR_ID INT
);
INSERT INTO EMP VALUES(1,'JOHN',0),(2,'MARY',1),(3,'STEVE',1),(4,'JACK',2),(5,'SUE',2);

SELECT E1.NAME , E2.NAME
FROM EMP E1,
	EMP E2
WHERE E1.MGR_ID = E2.ID;

SELECT E1.NAME , E2.NAME
FROM EMP E1,
	EMP E2
WHERE E1.MGR_ID - 1 = E2.MGR_ID  ;



/*第十四章*/

#关联字查询，子查询里有依赖于主查询的数据
SELECT C.CUST_NAME 
FROM CUSTOMER_TBL C
WHERE 10 < (
	SELECT SUM(O.QTY)
	FROM ORDERS_TBL O
	WHERE O.CUST_ID = C.CUST_ID
);


SELECT C.CUST_NAME 
FROM CUSTOMER_TBL C
WHERE 10 <
(SELECT SUM(O.QTY)
FROM ORDERS_TBL O
WHERE O.CUST_ID = C.CUST_ID
GROUP BY C.CUST_NAME);


/*第十五章*/
#UNION
SELECT EMP_ID AS TETS FROM EMPLOYEE_TBL1
UNION 
SELECT EMP_ID FROM EMPLOYEE_PAY_TBL1;

#UNION ALL
SELECT EMP_ID AS TETS FROM EMPLOYEE_TBL1
UNION ALL
SELECT EMP_ID FROM EMPLOYEE_PAY_TBL1;

#INTERSECT --返回两个select语句里一样的记录，但mysql尚不支持
SELECT EMP_ID AS TETS FROM EMPLOYEE_TBL1
INTERSECT
SELECT EMP_ID FROM EMPLOYEE_PAY_TBL1;

#EXCEPT --返回两个select语句里一样的记录，但mysql尚不支持
SELECT EMP_ID AS TETS FROM EMPLOYEE_TBL1
EXCEPT
SELECT EMP_ID FROM EMPLOYEE_PAY_TBL1;

#ORDER BY
SELECT EMP_ID AS TETS FROM EMPLOYEE_TBL1
UNION ALL
SELECT EMP_ID FROM EMPLOYEE_PAY_TBL1
ORDER BY 1;

#GROUP BY  --不太清楚这个有什么用
SELECT EMP_ID AS TETS FROM EMPLOYEE_TBL1
UNION ALL
SELECT EMP_ID FROM EMPLOYEE_PAY_TBL1
GROUP BY 1;

/*第十六章*/
#单字段索引
CREATE INDEX EMP_ID_IN ON EMPLOYEE_TBL1 (EMP_ID);

#唯一索引
CREATE UNIQUE INDEX NAME_FIR_IDX ON EMPLOYEE_TBL1 (FIRST_NAME);

#组合索引
CREATE INDEX ORD_INDEX ON ORDERS_TBL (CUST_ID,PROD_ID);

#修改索引
先删除后添加

#删除索引
DROP INDEX EMP_ID_IN ON EMPLOYEE_TBL1 ;

/*管理数据库用户*/

#创建用户 -- mariadb创建完之后无法访问，但mysql可以访问
GRANT ALL  ON *.* TO 'cwb'@'%' identified BY 'cwb';

#创建别的规划里的表
CREATE TABLE test.TEST(ID INT );

#修改用户密码
UPDATE mysql.user set Password = PASSWORD('cwb1') where user='cwb';

#更改用户名
RENAME USER cwb to cwb1;

#删除用户
DROP USER cwb1;


#收回权限
REVOKE SELECT on *.*  FROM 'cwb'@'%';

/*第十九章*/
#向用户授予权限
GRANT SELECT ON EMPLOYEE_TBL TO cwb1;

#使用GRANT OPTION--授予对象级权限

GRANT ALL ON *.* TO 'cwb2'@'%' identified by 'cwb2';
CREATE DATABASE TEST_C ;
CREATE USER 'cwb1'@'%' identified by 'cwb1';


GRANT SELECT ON TEST_C.customer_tbl TO cwb1 WITH GRANT OPTION;
GRANT SELECT,update,insert ON TEST_C.customer_tbl TO cwb3 WITH GRANT OPTION;

GRANT UPDATE(CUST_ID) ON CUSTOME_TBL1 TO PUBLIC;#不知道有什么效果

show grants for cwb
drop user cwb;
drop user cwb1;
drop user cwb2;
drop user cwb3;
select * from mysql.user;
select user();

#ADMIN OPTION--授予系统级权限--mysql似乎不支持，没有实现
GRANT CREATE TABLE TO cwb with 	ADMIN OPTION;

#REVOKE 
REVOKE ALL ON test_c.* FROM cwb;

#数据库用户PUBLIC，代表全体数据库
GRANT SELECT ON CUSTOME_TBL1 TO PUBLIC;

#权限组--mysql似乎不支持
GRANT DBA TO cwb;

#CREATE ORLE--mysql不支持
CREATE ROLE ROLE_NAME;;
GRANT SELECT,UPDATE,INSERT,DELETE ON custom_tbl1 TO ROLE_NAME;
GRANT ROLE_NAME TO cwb;
DROP ROLE_NAME;
SET ROLE ROLE_NAME;

#刷新权限
FLUSH PRIVILEGES;

/**/
通过root用户创建一个cwb账户，该账户显示所有的数据库，但有时又只会看到information_schema数据库
通过新建的cwb账户在创建一个cwb1账户，该账户只显示information_schema数据库
但有时


/*第二十章*/

#创建视图
CREATE VIEW VIEW_ALL AS
SELECT * FROM employee_tbl1;

#利用select里面的字段创建别名--未成功
CREATE VIEW NAMES AS
SELECT FIRST_NAME , MIDDLE_NAME VIEW_BIE FROM employee_tbl1;

#WITH CHECK OPTION
CREATE VIEW VIEW_CHECK AS
SELECT FIRST_NAME , PAGER 
FROM employee_tbl1
WHERE PAGER IS NOT NULL
WITH CHECK OPTION;

INSERT INTO VIEW_CHECK VALUES('SMITH',NULL)

#基于视图创建表

#删除视图
DROP VIEW VIEW_CHECK;

/*第二十一章*/
#列出test_c规划里的所有表格
USE INFORMATION_SCHEMA;
SELECT TABLE_NAME FROM TABLES WHERE TABLE_SCHEMA = 'test_c';

#返回数据库用户的全部权限--未实现
SELECT GRANTEE ,PRIVILEGE_TYPE FROM USER_PRIVILEGES WHERE GRANTEE = 'root';

/*第二十二章*/

#定义一个光标
DECLARE CURSOR_TEST CURSOR 
FOR SELECT * FROM employee_tbl1;



#创建一个触发器
delimiter //
CREATE TRIGGER TRIGGER_NAME
AFTER 
INSERT 
ON custome_tbl1
FOR EACH ROW
BEGIN 
UPDATE employee_tbl1 SET CITY = 'KE' WHERE EMP_ID =9;
end
//
delimiter ;
insert into custome_tbl1 values('1','1','1','1','1',1,1,1,'2018-9-10');

#删除触发器
DROP TRIGGER TRIGGER_NAME;

#使用XML


swGUBqpw@Sg8
